using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Letterbook.Generators;

[Generator]
public class TypedIdGenerator : IIncrementalGenerator
{
	// private static readonly Lazy<SyntaxReceiver> LazyReceiver = new();
	// private SyntaxReceiver Receiver => LazyReceiver.Value;

	// Adjust the namespace for your project
	private const string UuidName = "Medo.Uuid7";

	private static string GeneratorName =
		typeof(TypedIdGenerator).FullName ?? throw new InvalidOperationException("Error loading generator type");

	private static readonly ConcurrentDictionary<Type, string> IdTypeConverters = new();

	private static Model? Transformer(GeneratorAttributeSyntaxContext context, CancellationToken token)
	{
		if (context.TargetNode is not RecordDeclarationSyntax syntaxNode)
			return null;
		if (syntaxNode.ParameterList?.Parameters.SingleOrDefault(p => p.Identifier.Text == "Id") is not { } idParam)
			return null;
		if (idParam.Type?.ToString() is not { } iDTypeName)
			return null;

		var recordType = syntaxNode.ClassOrStructKeyword.Text == "struct" ? "record struct" : "record";
		return new Model(Namespace: GetNamespace(syntaxNode),
			TypeName: syntaxNode.Identifier.Text,
			IdTypeName: iDTypeName,
			RecordType: recordType);
	}

	public static bool PredicateFilter(SyntaxNode node, CancellationToken token)
	{
		var result = false;
		if (node is RecordDeclarationSyntax typeSyntax)
			result = typeSyntax.Modifiers.Any(t => t.Text == "partial");
		return result;
	}

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx =>
		{
			ctx.AddSource("GenerateTypedIdAttribute.g.cs", Helper.Attribute);
			ctx.AddSource("ITypedId.g.cs", Helper.Interface);
		});

		var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
				"Letterbook.Generators.GenerateTypedIdAttribute",
				predicate: PredicateFilter,
				transform: Transformer)
			.Where(static m => m is not null);

		context.RegisterImplementationSourceOutput(provider, OutputTypedIdAspTypeConverter!);
		context.RegisterImplementationSourceOutput(provider, OutputTypedIdJsonConverter!);
		context.RegisterImplementationSourceOutput(provider, OutputTypedIdEfConverter!);
		context.RegisterImplementationSourceOutput(provider, OutputTypedIdSwaggerSchema!);
		context.RegisterImplementationSourceOutput(provider, OutputTypedIdPartial!);
	}



	private static void OutputTypedIdPartial(SourceProductionContext context, Model model)
	{
		context.AddSource($"{model.TypeName}.g.cs", FormatTypedIdPartial(model));
	}

	private static void OutputTypedIdAspTypeConverter(SourceProductionContext context, Model model)
	{
		context.AddSource($"{model.TypeName}Converter.g.cs", FormatIdTypeConverter(model));
	}

	private static void OutputTypedIdJsonConverter(SourceProductionContext context, Model model)
	{
		context.AddSource($"{model.TypeName}JsonConverter.g.cs", FormatIdTypeJsonConverter(model));
	}

	private static void OutputTypedIdEfConverter(SourceProductionContext context, Model model)
	{
		context.AddSource($"{model.TypeName}EfConverter.g.cs", FormatTypedIdEfConverter(model));
	}

	private static void OutputTypedIdSwaggerSchema(SourceProductionContext context, Model model)
	{
		context.AddSource($"{model.TypeName}SwaggerSchemaFilter.g.cs", FormatTypedIdSwaggerSchema(model));
	}

	private static string FormatTypedIdSwaggerSchema(Model model)
	{
		var fullNamespace = model.Namespace;
		var idType = model.IdTypeName;
		var schemaType = idType == "int" ? "integer" : "string";
		var typeName = model.TypeName;
		var source =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using Letterbook.Generators;
			  using Microsoft.OpenApi.Any;
			  using Microsoft.OpenApi.Models;
			  using Swashbuckle.AspNetCore.SwaggerGen;

			  namespace {{fullNamespace}};

			  public class {{typeName}}SchemaFilter : ISchemaFilter
			  {
			      public void Apply(OpenApiSchema schema, SchemaFilterContext context)
			      {
			          schema.Type = "{{schemaType}}";
			          schema.Properties = null;
			          schema.Example = new OpenApiString(default({{typeName}}).ToString());
			      }
			  }
			  """;
		return source;
	}

	private static string FormatTypedIdEfConverter(Model model)
	{
		var fullNamespace = model.Namespace;
		var idType = model.IdTypeName;
		var isUuid7 = UuidName.EndsWith(idType);
		var dbTypeName = isUuid7 ? "Guid" : idType;
		var toDbType = isUuid7 ? ".ToGuid()" : "";
		var fromDbType = isUuid7 ? "new Medo.Uuid7(value)" : "value";
		var typeName = model.TypeName;
		var source =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
			  using Letterbook.Generators;

			  namespace {{fullNamespace}};

			  [TypedIdEfConverter<{{typeName}}>]
			  public class {{typeName}}EfConverter : ValueConverter<{{typeName}}, {{dbTypeName}}>
			  {
			      public {{typeName}}EfConverter() : base(id => id.Id{{toDbType}}, value => new({{fromDbType}})) { }
			  }
			  """;
		return source;
	}

	private static string FormatIdTypeJsonConverter(Model model)
	{
		var fullNamespace = model.Namespace;
		var idType = model.IdTypeName;
		var typeName = model.TypeName;
		var isUuid7 = UuidName.EndsWith(idType);
		var usingLine = isUuid7 ? "using Medo;" : "";

		var source =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using System.Text.Json;
			  using System.Text.Json.Serialization;
			  using Letterbook.Generators;
			  {{usingLine}}

			  namespace {{fullNamespace}};

			  [TypedIdJsonConverter]
			  public class {{typeName}}JsonConverter : JsonConverter<{{typeName}}>
			  {
			      /// <inheritdoc />
			      public override {{typeName}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			      {
			     		try
			     		{
			     			var value = JsonSerializer.Deserialize<{{idType}}>(ref reader, options);
			     			return new {{typeName}}(value);
			     		}
			     		catch (Exception e)
			     		{
			     			throw new JsonException("Unable to convert to {{typeName}}", e);
			     		}
			      }

			      /// <inheritdoc />
			      public override void Write(Utf8JsonWriter writer, {{typeName}} value, JsonSerializerOptions options)
			      {
			            JsonSerializer.Serialize(writer, value.Id, options);
			      }
			  }
			  """;
		return source;
	}

	private static string FormatIdTypeConverter(Model model)
	{
		var fullNamespace = model.Namespace;
		var typeName = model.TypeName;
		var idType = model.IdTypeName;
		var switchLine = idType == "string" ? "" : $"{idType} t => new {typeName}(t),";
		var isUuid7 = UuidName.EndsWith(idType);
		var usingLine = isUuid7 ? "using Medo;" : "";

		var result =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using System;
			  using System.ComponentModel;
			  using System.Globalization;
			  {{usingLine}}

			  namespace {{fullNamespace}};

			  public class {{typeName}}Converter : TypeConverter
			  {
			  	public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) =>
			  		sourceType == typeof(string);

			  	public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) =>
			  		destinationType == typeof(string);

			  	public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
			  	{
			  		return value switch
			  		{
			  			string s => new {{typeName}}({{typeName}}.FromString(s)),
			  			{{switchLine}}
			  			null => null,
			  			_ => throw new ArgumentException($"Cannot convert from {value} to {{typeName}}", nameof(value))
			  		};
			  	}

			  	public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
			  	{
			  		if (destinationType == typeof(string))
			  		{
			  			return value switch
			  			{
			  				{{typeName}} id => id.ToString(),
			  				null => null,
			  				_ => throw new ArgumentException($"Cannot convert {value} to string", nameof(value))
			  			};
			  		}
			  		else if (destinationType == typeof({{idType}}))
			  		{
			  			return value switch
			  			{
			  				{{typeName}} id => id.Id,
			  				null => null,
			  				_ => throw new ArgumentException($"Cannot convert {value} to string", nameof(value))
			  			};
			  		}

			  		throw new ArgumentException($"Cannot convert {value ?? "(null)"} to {destinationType}", nameof(destinationType));
			  	}
			  }
			  """;
		return result;
	}

	private static string FormatTypedIdPartial(Model model)
	{
		var fullNamespace = model.Namespace;// GetNamespace(source);
		var typeName = model.TypeName;// source.Identifier.Text;// type.Name;
		var idType = model.IdTypeName;// source.TypeParameterList!.Parameters.Single().Identifier.Text;// symbol.TypeArguments.Single();
		var isUuid7 = UuidName.EndsWith(idType);
		var toStringFn = isUuid7
			? "ToId25String()"
			: "ToString()";
		var fromStringFn = isUuid7
			? "Uuid7.FromId25String(s)"
			: $"{idType}.Parse(s)";
		var usingLine = isUuid7 ? "using Medo;" : "";

		var result =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using System.ComponentModel;
			  using Swashbuckle.AspNetCore.Annotations;
			  {{usingLine}}

			  namespace {{fullNamespace}}
			  {
			      [SwaggerSchemaFilter(typeof({{typeName}}SchemaFilter))]
			      [TypeConverter(typeof({{typeName}}Converter))]
			      partial {{model.RecordType}} {{typeName}} : Letterbook.Generators.ITypedId<{{idType}}>
			      {
			          public override string ToString() => Id.{{toStringFn}};
			          public static {{idType}} FromString(string s) => {{fromStringFn}};

			          public static explicit operator {{idType}}({{typeName}} id) => id.Id;
			          public static implicit operator {{typeName}}({{idType}} id) => new {{typeName}}(id);
			      }
			  }
			  """;
		return result;
	}

	private static string GetNamespace(TypeDeclarationSyntax syntax)
	{
		// If we don't have a namespace at all we'll return an empty string
		// This accounts for the "default namespace" case
		var nameSpace = string.Empty;

		// Get the containing syntax node for the type declaration
		// (could be a nested type, for example)
		var potentialNamespaceParent = syntax.Parent;

		// Keep moving "out" of nested classes etc until we get to a namespace
		// or until we run out of parents
		while (potentialNamespaceParent != null &&
		       potentialNamespaceParent is not NamespaceDeclarationSyntax
		       && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
		{
			potentialNamespaceParent = potentialNamespaceParent.Parent;
		}

		if (potentialNamespaceParent is not BaseNamespaceDeclarationSyntax namespaceParent) return nameSpace;

		// Build up the final namespace by walking up the syntax tree until we no longer have a namespace declaration
		// We have a namespace. Use that as the type
		nameSpace = namespaceParent.Name.ToString();

		// Keep moving "out" of the namespace declarations until we
		// run out of nested namespace declarations
		while (true)
		{
			if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
			{
				break;
			}

			// Add the outer namespace as a prefix to the final namespace
			nameSpace = $"{namespaceParent.Name}.{nameSpace}";
			namespaceParent = parent;
		}

		// return the final namespace
		return nameSpace;
	}

	private class SyntaxReceiver : ISyntaxReceiver
	{
		public List<RecordDeclarationSyntax> CandidateDeclarations { get; } = new();

		public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
		{
			if (syntaxNode is not RecordDeclarationSyntax declaration) return;
			if (declaration.HasInterface("ITypedId"))
			{
				CandidateDeclarations.Add(declaration);
			}
		}
	}

	private class Model(string Namespace, string TypeName, string IdTypeName, string RecordType)
	{
		public string Namespace { get; } = Namespace;
		public string TypeName { get; } = TypeName;
		public string IdTypeName { get; } = IdTypeName;
		public string RecordType { get; } = RecordType;
	}
}