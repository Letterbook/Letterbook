using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Letterbook.Generators;

[Generator]
public class TypedIdGenerator : IIncrementalGenerator
{
	// private static readonly Lazy<SyntaxReceiver> LazyReceiver = new();
	// private SyntaxReceiver Receiver => LazyReceiver.Value;

	// Adjust the namespace for your project
	private const string TypedIdName = "Letterbook.Generators.ITypedId<T>";
	private const string UuidName = "Medo.Uuid7";

	private static string GeneratorName =
		typeof(TypedIdGenerator).FullName ?? throw new InvalidOperationException("Error loading generator type");

	private static readonly ConcurrentDictionary<Type, string> IdTypeConverters = new();

	public RecordDeclarationSyntax Transformer(GeneratorSyntaxContext syntaxContext, CancellationToken token)
	{
		throw new NotImplementedException();
	}

	public bool PredicateFilter(SyntaxNode node, CancellationToken token)
	{
		return false;
	}

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Uncomment the next line to debug the source generator
		// System.Diagnostics.Debugger.Launch();

		var provider = context.SyntaxProvider.CreateSyntaxProvider(
			predicate: PredicateFilter,
			transform: Transformer);
		context.RegisterSourceOutput(provider, OutputTypedIdPartial);

		// context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Filename.g.cs", SourceText.From(sour)))
		// context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
	}

	private static void OutputTypedIdPartial(SourceProductionContext context, RecordDeclarationSyntax source)
	{
		context.AddSource($"{source.Identifier.Text}.g.cs", FormatTypedIdPartial(context, source));
	}

	// public void Initialize(GeneratorInitializationContext context)
	// {
		// Uncomment the next line to debug the source generator
		// System.Diagnostics.Debugger.Launch();
		// context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
	// }

	// static void Execute(EnumToGenerate? enumToGenerate, SourceProductionContext context)
	// {

	// }

	// public void Execute(IncrementalGen context)
	// {
	// 	if (context.SyntaxReceiver is not SyntaxReceiver receiver)
	// 		return;
	//
	// 	foreach (var declaration in receiver.CandidateDeclarations)
	// 	{
	// 		var model = context.Compilation.GetSemanticModel(declaration.SyntaxTree);
	// 		var type = model.GetDeclaredSymbol(declaration);
	// 		if (type is null)
	// 			continue;
	//
	// 		if (type.AllInterfaces.FirstOrDefault(t => t.ConstructedFrom.ToString() == TypedIdName) is not { } symbol)
	// 			continue;
	//
	// 		AddIdPartial(context, type, symbol);
	// 		AddIdTypeConverter(context, type, symbol);
	// 		AddIdTypeJsonConverter(context, type, symbol);
	// 		AddIdTypeEFConverter(context, type, symbol);
	// 		AddIdTypeSwaggerSchema(context, type, symbol);
	// 	}
	// }

	private void AddIdTypeSwaggerSchema(GeneratorExecutionContext context, INamedTypeSymbol type, INamedTypeSymbol symbol)
	{
		var fullNamespace = type.ContainingNamespace.ToDisplayString();
		var idType = symbol.TypeArguments.Single();
		var schemaType = idType.ToString() == "int" ? "integer" : "string";
		var typeName = type.Name;
		var source =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using Letterbook.Generators;
			  using Microsoft.OpenApi.Any;
			  using Microsoft.OpenApi.Models;
			  using Swashbuckle.AspNetCore.SwaggerGen;

			  namespace {{fullNamespace}};

			  public class {{typeName}}SchemaFilter : ISchemaFilter
			  {
			      public void Apply(OpenApiSchema schema, SchemaFilterContext context)
			      {
			          schema.Type = "{{schemaType}}";
			          schema.Properties = null;
			          schema.Example = new OpenApiString(default({{typeName}}).ToString());
			      }
			  }
			  """;

		context.AddSource($"{typeName}SwaggerSchemaFilter.g.cs", source);

	}

	private void AddIdTypeEFConverter(GeneratorExecutionContext context, INamedTypeSymbol type, INamedTypeSymbol symbol)
	{
		var fullNamespace = type.ContainingNamespace.ToDisplayString();
		var idType = symbol.TypeArguments.Single();
		var isUuid7 = idType.ToString() == UuidName;
		var dbTypeName = isUuid7 ? "Guid" : idType.ToString();
		var toDbType = isUuid7 ? ".ToGuid()" : "";
		var fromDbType = isUuid7 ? "new Medo.Uuid7(value)" : "value";
		var typeName = type.Name;
		var source =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
			  using Letterbook.Generators;

			  namespace {{fullNamespace}};

			  [TypedIdEfConverter<{{typeName}}>]
			  public class {{typeName}}EfConverter : ValueConverter<{{typeName}}, {{dbTypeName}}>
			  {
			      public {{typeName}}EfConverter() : base(id => id.Id{{toDbType}}, value => new({{fromDbType}})) { }
			  }
			  """;
		context.AddSource($"{typeName}EfConverter.g.cs", source);
	}

	private void AddIdTypeJsonConverter(GeneratorExecutionContext context, INamedTypeSymbol type, INamedTypeSymbol symbol)
	{
		var fullNamespace = type.ContainingNamespace.ToDisplayString();
		var idType = symbol.TypeArguments.Single();
		var typeName = type.Name;
		var source =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using System.Text.Json;
			  using System.Text.Json.Serialization;
			  using Letterbook.Generators;

			  namespace {{fullNamespace}};

			  [TypedIdJsonConverter]
			  public class {{typeName}}JsonConverter : JsonConverter<{{typeName}}>
			  {
			      /// <inheritdoc />
			      public override {{typeName}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			      {
			     		try
			     		{
			     			var value = JsonSerializer.Deserialize<{{idType}}>(ref reader, options);
			     			return new {{typeName}}(value);
			     		}
			     		catch (Exception e)
			     		{
			     			throw new JsonException("Unable to convert to {{typeName}}", e);
			     		}
			      }

			      /// <inheritdoc />
			      public override void Write(Utf8JsonWriter writer, {{typeName}} value, JsonSerializerOptions options)
			      {
			            JsonSerializer.Serialize(writer, value.Id, options);
			      }
			  }
			  """;
		context.AddSource($"{typeName}JsonConverter.g.cs", source);
	}

	private void AddIdTypeConverter(GeneratorExecutionContext context, INamedTypeSymbol type, INamedTypeSymbol symbol)
	{
		var fullNamespace = type.ContainingNamespace.ToDisplayString();
		var typeName = type.Name;
		var idType = symbol.TypeArguments.Single();
		var switchLine = idType.ToString() == "string" ? "" : $"{idType} t => new {typeName}(t),";

		var source =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using System;
			  using System.ComponentModel;
			  using System.Globalization;


			  namespace {{fullNamespace}};

			  public class {{typeName}}Converter : TypeConverter
			  {
			  	public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) =>
			  		sourceType == typeof(string);

			  	public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) =>
			  		destinationType == typeof(string);

			  	public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
			  	{
			  		return value switch
			  		{
			  			string s => new {{typeName}}({{typeName}}.FromString(s)),
			  			{{switchLine}}
			  			null => null,
			  			_ => throw new ArgumentException($"Cannot convert from {value} to {{typeName}}", nameof(value))
			  		};
			  	}

			  	public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
			  	{
			  		if (destinationType == typeof(string))
			  		{
			  			return value switch
			  			{
			  				{{typeName}} id => id.ToString(),
			  				null => null,
			  				_ => throw new ArgumentException($"Cannot convert {value} to string", nameof(value))
			  			};
			  		}
			  		else if (destinationType == typeof({{idType}}))
			  		{
			  			return value switch
			  			{
			  				{{typeName}} id => id.Id,
			  				null => null,
			  				_ => throw new ArgumentException($"Cannot convert {value} to string", nameof(value))
			  			};
			  		}

			  		throw new ArgumentException($"Cannot convert {value ?? "(null)"} to {destinationType}", nameof(destinationType));
			  	}
			  }
			  """;
		context.AddSource($"{typeName}Converter.g.cs", source);
	}

	private static string FormatTypedIdPartial(SourceProductionContext context, RecordDeclarationSyntax source)
	{
		var fullNamespace = GetNamespace(source);
		var typeName = source.Identifier.Text;// type.Name;
		var idType = source.TypeParameterList!.Parameters.Single().Identifier.Text;// symbol.TypeArguments.Single();
		var isUuid7 = idType.ToString() == UuidName;
		var toStringFn = isUuid7
			? "ToId25String()"
			: "ToString()";
		var fromStringFn = isUuid7
			? "Medo.Uuid7.FromId25String(s)"
			: $"{idType}.Parse(s)";
		var typeDef = source.Keyword;// type.IsValueType
			// ? "record struct"
			// : "record";

		var result =
			$$"""
			  // <auto-generated from {{GeneratorName}}/>

			  using System.ComponentModel;
			  using Swashbuckle.AspNetCore.Annotations;

			  namespace {{fullNamespace}}
			  {
			      [SwaggerSchemaFilter(typeof({{typeName}}SchemaFilter))]
			      [TypeConverter(typeof({{typeName}}Converter))]
			      partial {{typeDef}} {{typeName}}
			      {
			          public override string ToString() => Id.{{toStringFn}};
			          public static {{idType}} FromString(string s) => {{fromStringFn}};

			          public static explicit operator {{idType}}({{typeName}} id) => id.Id;
			          public static implicit operator {{typeName}}({{idType}} id) => new {{typeName}}(id);
			      }
			  }
			  """;
		return result;
	}

	private static string GetNamespace(TypeDeclarationSyntax syntax)
	{
		// If we don't have a namespace at all we'll return an empty string
		// This accounts for the "default namespace" case
		string nameSpace = string.Empty;

		// Get the containing syntax node for the type declaration
		// (could be a nested type, for example)
		SyntaxNode? potentialNamespaceParent = syntax.Parent;

		// Keep moving "out" of nested classes etc until we get to a namespace
		// or until we run out of parents
		while (potentialNamespaceParent != null &&
		       potentialNamespaceParent is not NamespaceDeclarationSyntax
		       && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
		{
			potentialNamespaceParent = potentialNamespaceParent.Parent;
		}

		// Build up the final namespace by looping until we no longer have a namespace declaration
		if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
		{
			// We have a namespace. Use that as the type
			nameSpace = namespaceParent.Name.ToString();

			// Keep moving "out" of the namespace declarations until we
			// run out of nested namespace declarations
			while (true)
			{
				if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
				{
					break;
				}

				// Add the outer namespace as a prefix to the final namespace
				nameSpace = $"{namespaceParent.Name}.{nameSpace}";
				namespaceParent = parent;
			}
		}

		// return the final namespace
		return nameSpace;
	}

	private class SyntaxReceiver : ISyntaxReceiver
	{
		public List<RecordDeclarationSyntax> CandidateDeclarations { get; } = new();

		public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
		{
			if (syntaxNode is not RecordDeclarationSyntax declaration) return;
			if (declaration.HasInterface("ITypedId"))
			{
				CandidateDeclarations.Add(declaration);
			}
		}
	}
}